/*
***** Н А Ч А Л О   файла компилятора с языка высокого уровня
*/

/*
***** Б л о к  об'явлений макроопределений
*/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

/* предельные размеры: */
#define MAXNISXTXT 50                             /* - исходного текста;    */
#define NSINT     242                             /* - табл.синтакс.правил; */
#define NCEL       20                             /* - стека целей;         */
#define NDST      500                             /* - стека достижений;    */
#define NVXOD      54                             /* - табл.входов;         */
#define NSTROKA   200                             /* - строки плотн.текста; */
#define NNETRM     17                             /* - списка нетерминалов; */
#define MAXLTXT    50                             /* - выходного текста;    */
#define MAXFORMT   30                             /* - форматированного интерпретируемого  фрагмента исх.текста; */
#define NSYM      100                             /* - таблицы имен и меток */

#define dbg(fmt, args...) printf("<<<DEBUG>>>%s[%u]"fmt"\n", __FUNCTION__, __LINE__, ##args);
#define err(fmt, args...) printf("<<<ERROR>>>%s[%u]"fmt"\n", __FUNCTION__, __LINE__, ##args);

#define IBM370_ASM_COMPARE_LOGICAL_REGISTERS        "CLR"

#define IBM370_ASM_STATUS_EQUAL                     "8"
#define IBM370_ASM_STATUS_NOT_EQUAL                 "15"

#define IBM370_VAR_TYPE                             char

#define IBM370_VAR_TYPE_PACKED_DECIMAL              'D'
#define IBM370_VAR_TYPE_BINARY                      'B'
#define READABLE                                    0

#define IBM370_ASM_STORE                            "ST"
#define IBM370_ASM_LOAD                             "L"
#define IBM370_ASM_CONVERT_PACKED_DECIMAL_TO_BINARY "CVB"
#define IBM370_ASM_CONVERT_BINARY_TO_PACKED_DECIMAL "CVD"
#define IBM370_ASM_CONDITIONAL_BRANCH               "BC"
#define IBM370_ASM_MOVE_CHARACTERS                  "MVC"
#define IBM370_ASM_LOAD_HALFWORD                    "LH"
#define IBM370_ASM_COMPARE_ALGEBROIC                "CR"

inline int IndexNotFound()
{
    return -1;
}

typedef enum CODEGEN_ERRORS_TAG
{
    // "трансляция завершена успешно"
     ERROR_SUCCESS                   = 0,

    // "несовпадение имени процедуры в прологе-эпилоге"
     ERROR_PROCNAME_DOESNT_MATCH     = 1,

    // "недопустимый тип идентификатора"
    ERROR_VAR_TYPE1                 = 2,

    //  "недопустимый тип идентификатора"
    ERROR_VAR_TYPE2                 = 3,

    //  "неопределенный идентификатор"
    ERROR_VAR_NOT_DEFINED           = 4,

    //  "недопустимая операция"
    ERROR_OPERATION_NOT_SUPPORTED   = 5,

    //  "повторное объявление идентификатора"
    ERROR_VAR_ALREADY_DEFINED       = 6

}   CODEGEN_ERRORS;

/*
***** Б а з а  данных компилятора
*/

/*
***** Б л о к  об'явления массива с исходным текстом
*/

unsigned NISXTXT;                                     /* длина массива          */
char ISXTXT [MAXNISXTXT][80];                     /* тело массива           */

/*
***** Б л о к  об'явления рабочих переменных
*/

/* счетчики циклов */
int I1,I2,I3,I4;

/*место хранения уплотненного исходного текста */
char STROKA [ NSTROKA ];

/* текущие индексы соответственно в: */
int I;/* - уплотненном тексте; */
int J;/* - табл.грамм.правил; */
int K;/* - стеке поставленных целей */
int L;/* - стеке достигнутых целей; */

/* шаблон для генерации записи выходного файла на АССЕМБЛЕРЕ IBM 370 */
typedef union IBM370_ASM_COMMAND
{
    char    BUFCARD [80];
    struct
    {
        char METKA   [8];
        char PROB1;
        char OPERAC  [5];
        char PROB2;
        char OPERAND [12];
        char PROB3;
        char COMM    [52];
    } _BUFCARD;
} IBM370_ASM_COMMAND;

static IBM370_ASM_COMMAND ASS_CARD;

char NextLabel[] = {'N'};
char OnEqualLabel[] = {'E'};
int NextLabelIndex = 0;
int OnEqualLabelIndex = 0;

/* массив для хранения выходного текста на АССЕМБЛЕРЕ IBM 370 */
char ASSTXT [ MAXLTXT ][80];

/* индекс выходного массива */
unsigned IASSTXT = 0;

/* массив для форматированного (в виде последовательности 9-ти позиционных строк-лексем) представления интерпретируемого фрагмента исходного плотного текста */
char FORMT [MAXFORMT] [9];

/* индекс форматированного массива */
int IFORMT;

static char *tmp_metka = NULL;

/*
***** Б л о к  об'явления таблиц базы данных
*/

/*
***** Т а б л и ц а, используемая как магазин (стек) достижений
*/

struct
{
    char DST1 [ 4 ];
    int  DST2;
    int  DST3;
    int  DST4;
    int  DST5;
}   DST [ NDST ];

/*
***** Т а б л и ц а, используемая как магазин (стек) целей
*/

struct
{
    char CEL1 [ 4 ];
    int  CEL2;
    int  CEL3;
}   CEL [ NCEL ];

/*
***** Т а б л и ц а, синтаксических правил, записанных в форме распознавания,
***** сгруппированных в "кусты" и представленных в виде двухнапрвленного
***** списка с альтернативными разветвлениями
*/

struct
 {
  int  POSL;
  int  PRED;
  char DER[4];
  int  ALT;
 } SINT [ NSINT ] =
/*   __________ _________ _______ _______ ______
    |  NN      :    посл : пред  :  дер  : альт |
    |__________:_________:_______:_______:______|                          */
{
 {/*.    0     .*/    -1 ,    -1 , "***" ,   -1 },
  /*                                               вход с символа - 0      */
 {/*.    1     .*/     2 ,     0 , "0  " ,    0 },
 {/*.    2     .*/     3 ,     1 , "CIF" ,    0 },
 {/*.    3     .*/     0 ,     2 , "*  " ,    0 },
  /*                                               вход с символа - 1      */
 {/*.    4     .*/     5 ,     0 , "1  " ,    0 },
 {/*.    5     .*/     6 ,     4 , "CIF" ,    7 },
 {/*.    6     .*/     0 ,     5 , "*  " ,    0 },

 {/*.    7     .*/     8 ,     4 , "MAN" ,    0 },
 {/*.    8     .*/     0 ,     7 , "*  " ,    0 },
  /*                                               вход с символа - 2      */
 {/*.    9     .*/    10 ,     0 , "2  " ,    0 },
 {/*.   10     .*/    11 ,     9 , "CIF" ,    0 },
 {/*.   11     .*/     0 ,    10 , "*  " ,    0 },
  /*                                               вход с символа - 3      */
 {/*.   12     .*/    13 ,     0 , "3  " ,    0 },
 {/*.   13     .*/    14 ,    12 , "CIF" ,    0 },
 {/*.   14     .*/     0 ,    13 , "*  " ,    0 },
  /*                                               вход с символа - 4      */
 {/*.   15     .*/    16 ,     0 , "4  " ,    0 },
 {/*.   16     .*/    17 ,    15 , "CIF" ,    0 },
 {/*.   17     .*/     0 ,    16 , "*  " ,    0 },
  /*                                               вход с символа - 5      */
 {/*.   18     .*/    19 ,     0 , "5  " ,    0 },
 {/*.   19     .*/    20 ,    18 , "CIF" ,    0 },
 {/*.   20     .*/     0 ,    19 , "*  " ,    0 },
  /*                                               вход с символа - 6      */
 {/*.   21     .*/    22 ,     0 , "6  " ,    0 },
 {/*.   22     .*/    23 ,    21 , "CIF" ,    0 },
 {/*.   23     .*/     0 ,    22 , "*  " ,    0 },
  /*                                               вход с символа - 7      */
 {/*.   24     .*/    25 ,     0 , "7  " ,    0 },
 {/*.   25     .*/    26 ,    24 , "CIF" ,    0 },
 {/*.   26     .*/     0 ,    25 , "*  " ,    0 },
  /*                                               вход с символа - 8      */
 {/*.   27     .*/    28 ,     0 , "8  " ,    0 },
 {/*.   28     .*/    29 ,    27 , "CIF" ,    0 },
 {/*.   29     .*/     0 ,    28 , "*  " ,    0 },
  /*                                               вход с символа - 9      */
 {/*.   30     .*/    31 ,     0 , "9  " ,    0 },
 {/*.   31     .*/    32 ,    30 , "CIF" ,    0 },
 {/*.   32     .*/     0 ,    31 , "*  " ,    0 },
  /*                                               вход с символа - A      */
 {/*.   33     .*/    34 ,     0 , "A  " ,    0 },
 {/*.   34     .*/    35 ,    33 , "BUK" ,    0 },
 {/*.   35     .*/     0 ,    34 , "*  " ,    0 },
  /*                                               вход с символа - B      */
 {/*.   36     .*/    37 ,     0 , "B  " ,    0 },
 {/*.   37     .*/    38 ,    36 , "BUK" ,    0 },
 {/*.   38     .*/     0 ,    37 , "*  " ,    0 },
  /*                                               вход с символа - C      */
 {/*.   39     .*/    40 ,     0 , "C  " ,    0 },
 {/*.   40     .*/    41 ,    39 , "BUK" ,    0 },
 {/*.   41     .*/     0 ,    40 , "*  " ,    0 },
  /*                                               вход с символа - D      */
 {/*.   42     .*/    43 ,     0 , "D  " ,    0 },
 {/*.   43     .*/    44 ,    42 , "BUK" ,   45 },
 {/*.   44     .*/     0 ,    43 , "*  " ,    0 },

 {/*.   45     .*/    46 ,    42 , "C  " ,    0 },
 {/*.   46     .*/    47 ,    45 , "L  " ,    0 },
 {/*.   47     .*/    48 ,    46 , "   " ,    0 },
 {/*.   48     .*/    49 ,    47 , "IDE" ,    0 },
 {/*.   49     .*/    50 ,    48 , "   " ,    0 },
 {/*.   50     .*/    51 ,    49 , "B  " ,  187 },
 {/*.   51     .*/    52 ,    50 , "I  " ,    0 },
 {/*.   52     .*/    53 ,    51 , "N  " ,    0 },
 {/*.   53     .*/    54 ,    52 , "   " ,    0 },
 {/*.   54     .*/    55 ,    53 , "F  " ,    0 },
 {/*.   55     .*/    56 ,    54 , "I  " ,    0 },
 {/*.   56     .*/    57 ,    55 , "X  " ,    0 },
 {/*.   57     .*/    58 ,    56 , "E  " ,    0 },
 {/*.   58     .*/    59 ,    57 , "D  " ,    0 },
 {/*.   59     .*/    60 ,    58 , "(  " ,  201 },
 {/*.   60     .*/    61 ,    59 , "RZR" ,    0 },
 {/*.   61     .*/    62 ,    60 , ")  " ,    0 },
 {/*.   62     .*/    63 ,    61 , ";  " ,   65 },
 {/*.   63     .*/    64 ,    62 , "ODC" ,    0 },
 {/*.   64     .*/    65 ,    63 , "*  " ,    0 },

 {/*.   65     .*/    66 ,    61 , "I  " ,    0 },
 {/*.   66     .*/    67 ,    65 , "N  " ,    0 },
 {/*.   67     .*/    68 ,    66 , "I  " ,    0 },
 {/*.   68     .*/    69 ,    67 , "T  " ,    0 },
 {/*.   69     .*/    70 ,    68 , "(  " ,    0 },
 {/*.   70     .*/    71 ,    69 , "LIT" ,    0 },
 {/*.   71     .*/    72 ,    70 , ")  " ,    0 },
 {/*.   72     .*/    73 ,    71 , ";  " ,    0 },
 {/*.   73     .*/   186 ,    72 , "ODC" ,    0 },
  /*                                               вход с символа - E      */
 {/*.   74     .*/    75 ,     0 , "E  " ,    0 },
 {/*.   75     .*/    76 ,    74 , "N  " ,   82 },
 {/*.   76     .*/    77 ,    75 , "D  " ,    0 },
 {/*.   77     .*/    78 ,    76 , "   " ,    0 },
 {/*.   78     .*/    79 ,    77 , "IPR" ,    0 },
 {/*.   79     .*/    80 ,    78 , ";  " ,    0 },
 {/*.   80     .*/    81 ,    79 , "OEN" ,    0 },
 {/*.   81     .*/     0 ,    80 , "*  " ,    0 },

 {/*.   82     .*/    83 ,    74 , "BUK" ,    0 },
 {/*.   83     .*/     0 ,    82 , "*  " ,    0 },
  /*                                               вход с символа - M      */
 {/*.   84     .*/    85 ,     0 , "M  " ,    0 },
 {/*.   85     .*/    86 ,    84 , "BUK" ,    0 },
 {/*.   86     .*/     0 ,    85 , "*  " ,    0 },
  /*                                               вход с символа - P      */
 {/*.   87     .*/    88 ,     0 , "P  " ,    0 },
 {/*.   88     .*/    89 ,    87 , "BUK" ,    0 },
 {/*.   89     .*/     0 ,    88 , "*  " ,    0 },
  /*                                               вход с символа - X      */
 {/*.   90     .*/    91 ,     0 , "X  " ,    0 },
 {/*.   91     .*/    92 ,    90 , "BUK" ,    0 },
 {/*.   92     .*/     0 ,    91 , "*  " ,    0 },
  /*                                               вход с символа - BUK    */
 {/*.   93     .*/    94 ,     0 , "BUK" ,    0 },
 {/*.   94     .*/    95 ,    93 , "IDE" ,    0 },
 {/*    95     .*/     0 ,    94 , "*  " ,    0 },
  /*                                               вход с символа - IDE    */
 {/*.   96     .*/    97 ,     0 , "IDE" ,    0 },
 {/*.   97     .*/    98 ,    96 , "BUK" ,  100 },
 {/*.   98     .*/    99 ,    97 , "IDE" ,    0 },
 {/*.   99     .*/     0 ,    98 , "*  " ,    0 },

 {/*.  100     .*/   101 ,    96 , "CIF" ,  103 },
 {/*.  101     .*/   102 ,   100 , "IDE" ,    0 },
 {/*.  102     .*/     0 ,   101 , "*  " ,    0 },

 {/*.  103     .*/   104 ,    96 , "IPE" ,  105 },
 {/*.  104     .*/     0 ,   103 , "*  " ,    0 },

 {/*.  105     .*/   106 ,    96 , "IPR" ,    0 },
 {/*.  106     .*/     0 ,   105 , "*  " ,    0 },
  /*                                               вход с символа - +      */
 {/*.  107     .*/   108 ,     0 , "+  " ,    0 },
 {/*.  108     .*/   109 ,   107 , "ZNK" ,    0 },
 {/*.  109     .*/     0 ,   108 , "*  " ,    0 },
  /*                                               вход с символа - -      */
 {/*.  110     .*/   111 ,     0 , "-  " ,    0 },
 {/*.  111     .*/   112 ,   110 , "ZNK" ,    0 },
 {/*.  112     .*/     0 ,   111 , "*  " ,    0 },
  /*                                               вход с символа - IPR    */
 {/*.  113     .*/   114 ,     0 , "IPR" ,    0 },
 {/*.  114     .*/   115 ,   113 , ":  " ,    0 },
 {/*.  115     .*/   116 ,   114 , "P  " ,    0 },
 {/*.  116     .*/   117 ,   115 , "R  " ,    0 },
 {/*.  117     .*/   118 ,   116 , "O  " ,    0 },
 {/*.  118     .*/   119 ,   117 , "C  " ,    0 },
 {/*.  119     .*/   120 ,   118 , "   " ,    0 },
 {/*.  120     .*/   121 ,   119 , "O  " ,    0 },
 {/*.  121     .*/   122 ,   120 , "P  " ,    0 },
 {/*.  122     .*/   123 ,   121 , "T  " ,    0 },
 {/*.  123     .*/   124 ,   122 , "I  " ,    0 },
 {/*.  124     .*/   125 ,   123 , "O  " ,    0 },
 {/*.  125     .*/   126 ,   124 , "N  " ,    0 },
 {/*.  126     .*/   127 ,   125 , "S  " ,    0 },
 {/*.  127     .*/   128 ,   126 , "(  " ,    0 },
 {/*.  128     .*/   129 ,   127 , "M  " ,    0 },
 {/*.  129     .*/   130 ,   128 , "A  " ,    0 },
 {/*.  130     .*/   131 ,   129 , "I  " ,    0 },
 {/*.  131     .*/   132 ,   130 , "N  " ,    0 },
 {/*.  132     .*/   133 ,   131 , ")  " ,    0 },
 {/*.  133     .*/   134 ,   132 , ";  " ,    0 },
 {/*.  134     .*/   135 ,   133 , "OPR" ,    0 },
 {/*.  135     .*/     0 ,   134 , "*  " ,    0 },
 /*                                                вход с символа - CIF    */
 {/*.  136     .*/   137 ,     0 , "CIF" ,    0 },
 {/*.  137     .*/   138 ,   136 , "RZR" ,    0 },
 {/*.  138     .*/     0 ,     0 , "*  " ,    0 },
  /*                                               вход с символа - RZR    */
 {/*.  139     .*/   140 ,     0 , "RZR" ,    0 },
 {/*.  140     .*/   141 ,   139 , "CIF" ,    0 },
 {/*.  141     .*/   142 ,   140 , "RZR" ,    0 },
 {/*.  142     .*/     0 ,   141 , "*  " ,    0 },
  /*                                               вход с символа - MAN    */
 {/*.  143     .*/   144 ,     0 , "MAN" ,    0 },
 {/*.  144     .*/   145 ,   143 , "B  " ,  147 },
 {/*.  145     .*/   146 ,   144 , "LIT" ,    0 },
 {/*.  146     .*/     0 ,   145 , "*  " ,    0 },

 {/*.  147     .*/   148 ,   143 , "0  " ,  150 },
 {/*.  148     .*/   149 ,   147 , "MAN" ,    0 },
 {/*.  149     .*/     0 ,   148 , "*  " ,    0 },

 {/*.  150     .*/   151 ,   143 , "1  " ,    0 },
 {/*.  151     .*/   152 ,   150 , "MAN" ,    0 },
 {/*.  152     .*/     0 ,   151 , "*  " ,    0 },
  /*                                               вход с символа - IPE    */
 {/*.  153     .*/   154 ,     0 , "IPE" ,    0 },
 {/*.  154     .*/   155 ,   153 , "=  " ,  159 },
 {/*.  155     .*/   156 ,   154 , "AVI" ,  235 }, //CMP
 {/*.  156     .*/   157 ,   155 , ";  " ,    0 },
 {/*.  157     .*/   158 ,   156 , "OPA" ,    0 },
 {/*.  158     .*/     0 ,   157 , "*  " ,    0 },

 {/*.  159     .*/   160 ,   153 , "AVI" ,    0 },
 {/*.  160     .*/     0 ,   159 , "*  " ,    0 },
  /*                                               вход с символа - LIT    */
 {/*.  161     .*/   162 ,     0 , "LIT" ,    0 },
 {/*.  162     .*/   163 ,   161 , "AVI" ,    0 },
 {/*.  163     .*/     0 ,   162 , "*  " ,    0 },
  /*.                                              вход с символа - AVI    */
 {/*.  164     .*/   165 ,     0 , "AVI" ,    0 },
 {/*.  165     .*/   166 ,   164 , "ZNK" ,    0 },
 {/*.  166     .*/   167 ,   165 , "LIT" ,  168 },
 {/*.  167     .*/   197 ,   166 , "AVI" ,    0 },

 {/*.  168     .*/   169 ,   165 , "IPE" ,    0 },
 {/*.  169     .*/   170 ,   168 , "AVI" ,    0 },
 {/*.  170     .*/     0 ,   169 , "*  " ,    0 },
  /*                                               вход с символа - OPR    */
 {/*.  171     .*/   172 ,     0 , "OPR" ,    0 },
 {/*.  172     .*/   173 ,   171 , "TEL" ,    0 },
 {/*.  173     .*/   174 ,   172 , "OEN" ,    0 },
 {/*.  174     .*/   175 ,   173 , "PRO" ,    0 },
 {/*.  175     .*/     0 ,   174 , "*  " ,    0 },
  /*.                                              вход с символа - ODC    */
 {/*.  176     .*/   177 ,     0 , "ODC" ,    0 },
 {/*.  177     .*/   178 ,   176 , "TEL" ,    0 },
 {/*.  178     .*/     0 ,   177 , "*  " ,    0 },
  /*.                                              вход с символа - TEL    */
 {/*.  179     .*/   180 ,     0 , "TEL" ,    0 },
 {/*.  180     .*/   181 ,   179 , "ODC" ,  183 },
 {/*.  181     .*/   182 ,   180 , "TEL" ,    0 },
 {/*.  182     .*/     0 ,   181 , "*  " ,    0 },

 {/*.  183     .*/   184 ,   179 , "OPA" ,    0 },
 {/*.  184     .*/   185 ,   183 , "TEL" ,    0 },
 {/*.  185     .*/     0 ,   184 , "*  " ,    0 },

 {/*.  186     .*/     0 ,    73 , "*  " ,    0 },


 {/*.  187     .*/   188 ,    49 , "C  " ,  215 },
 {/*.  188     .*/   189 ,   187 , "H  " ,    0 },
 {/*.  189     .*/   190 ,   188 , "A  " ,    0 },
 {/*.  190     .*/   191 ,   189 , "R  " ,    0 },
 {/*.  191     .*/   192 ,   190 , "(  " ,    0 },
 {/*.  192     .*/   193 ,   191 , "RZR" ,    0 },
 {/*.  193     .*/   194 ,   192 , ")  " ,    0 },
 {/*.  194     .*/   195 ,   193 , ";  " ,    0 },
 {/*.  195     .*/   196 ,   194 , "ODC" ,    0 },
 {/*.  196     .*/     0 ,   195 , "*  " ,    0 },

 {/*.  197     .*/     0 ,   166 , "*  " ,    0 },

 {/*.  198     .*/   199 ,     0 , "*  " ,    0 },
 {/*.  199     .*/   200 ,   198 , "ZNK" ,    0 },
 {/*.  200     .*/     0 ,   199 , "*  " ,    0 },
/* Альтернативный переход для случая DCL <IPE> BIN FIXED; */

 {/*.  201     .*/   202 ,    59 , ";  " ,  204 },
 {/*.  202     .*/   203 ,   201 , "ODC" ,    0 },
 {/*.  203     .*/     0 ,   202 , "*  " ,    0 },

 /* Альтернативный переход для случая DCL <IPE> BIN FIXED INIT(<RZR>);

 прыгаем ПОСЛЕ FIXED

 */

 {/*.  204     .*/   205 ,   201 , "   " ,    0 },
 {/*.  205     .*/   206 ,   204 , "I  " ,    0 },
 {/*.  206     .*/   207 ,   205 , "N  " ,    0 },
 {/*.  207     .*/   208 ,   206 , "I  " ,    0 },
 {/*.  208     .*/   209 ,   207 , "T  " ,    0 },
 {/*.  209     .*/   210 ,   208 , "(  " ,    0 },
 {/*.  210     .*/   211 ,   209 , "RZR" ,    0 },
 {/*.  211     .*/   212 ,   210 , ")  " ,    0 },
 {/*.  212     .*/   213 ,   211 , ";  " ,    0 },
 {/*.  213     .*/   214 ,   212 , "ODC" ,    0 },
 {/*.  214     .*/     0 ,   213 , "*  " ,    0 },

 /* Альтернативный переход для случая DCL <IPE> DEC FIXED INIT(<RZR>);

 ПРЫГАЕМ ПЕРЕД char

 */

 {/*.  215     .*/   216 ,   187 , "D  " ,    0 },
 {/*.  216     .*/   217 ,   215 , "E  " ,    0 },
 {/*.  217     .*/   218 ,   216 , "C  " ,    0 },
 {/*.  218     .*/   219 ,   217 , "   " ,    0 },
 {/*.  219     .*/   220 ,   218 , "F  " ,    0 },
 {/*.  220     .*/   221 ,   219 , "I  " ,    0 },
 {/*.  221     .*/   222 ,   220 , "X  " ,    0 },
 {/*.  222     .*/   223 ,   221 , "E  " ,    0 },
 {/*.  223     .*/   224 ,   222 , "D  " ,    0 },
 {/*.  224     .*/   225 ,   223 , "   " ,    0 },
 {/*.  225     .*/   226 ,   224 , "I  " ,    0 },
 {/*.  226     .*/   227 ,   225 , "N  " ,    0 },
 {/*.  227     .*/   228 ,   226 , "I  " ,    0 },
 {/*.  228     .*/   229 ,   227 , "T  " ,    0 },
 {/*.  229     .*/   230 ,   228 , "(  " ,    0 },
 {/*.  230     .*/   231 ,   229 , "RZR" ,    0 },
 {/*.  231     .*/   232 ,   230 , ")  " ,    0 },
 {/*.  232     .*/   233 ,   231 , ";  " ,    0 },
 {/*.  233     .*/   234 ,   232 , "ODC" ,    0 },
 {/*.  234     .*/     0 ,   233 , "*  " ,    0 },

 /* IPE = CMP; -> OPA                          */

 {/*.  235     .*/   236 ,   154 , "CMP" ,  239 },//альт: IPE = IPE  CMP
 {/*.  236     .*/   237 ,   235 , ";  " ,    0 },
 {/*.  237     .*/   238 ,   236 , "OPA" ,    0 },
 {/*.  238     .*/     0 ,   237 , "*  " ,    0 },

 /* IPE = IPE -> CMP                           */
 {/*.  239     .*/   240 ,   154 , "IPE" ,    0 },
 {/*.  240     .*/   241 ,   239 , "CMP" ,    0 },
 {/*.  241     .*/     0 ,   240 , "*  " ,    0 }
};

/*
***** Т а б л и ц а  входов в "кусты" ( корней )грамматических правил,
***** содержащая тип ( терминальность или нетерминальность ) корневых
***** символов
*/

struct
 {
  char SYM [4];
  int  VX;
  char TYP;
 } VXOD [ NVXOD ] =
/*   __________ ___________ _____ ______
    |  NN      |    символ | вход| тип  |
    |__________|___________|_____|______|                                  */

{
  {/*.   1     .*/   "AVI" , 164 , 'N' },
  {/*.   2     .*/   "BUK" ,  93 , 'N' },
  {/*.   3     .*/   "CIF" , 136 , 'N' },
  {/*.   4     .*/   "IDE" ,  96 , 'N' },
  {/*.   5     .*/   "IPE" , 153 , 'N' },
  {/*.   6     .*/   "IPR" , 113 , 'N' },
  {/*.   7     .*/   "LIT" , 161 , 'N' },
  {/*.   8     .*/   "MAN" , 143 , 'N' },
  {/*.   9     .*/   "ODC" , 176 , 'N' },
  {/*.  10     .*/   "OEN" ,   0 , 'N' },
  {/*.  11     .*/   "OPA" ,   0 , 'N' },
  {/*.  12     .*/   "OPR" , 171 , 'N' },
  {/*.  13     .*/   "PRO" ,   0 , 'N' },
  {/*.  14     .*/   "RZR" , 139 , 'N' },
  {/*.  15     .*/   "TEL" , 179 , 'N' },
  {/*.  16     .*/   "ZNK" ,   0 , 'N' },
  {/*.  17     .*/   "CMP" , 235 , 'N' },
  {/*.  18     .*/   "A  " ,  33 , 'T' },
  {/*.  19     .*/   "B  " ,  36 , 'T' },
  {/*.  20     .*/   "C  " ,  39 , 'T' },
  {/*.  21     .*/   "D  " ,  42 , 'T' },
  {/*.  22     .*/   "E  " ,  74 , 'T' },
  {/*.  23     .*/   "M  " ,  84 , 'T' },
  {/*.  24     .*/   "P  " ,  87 , 'T' },
  {/*.  25     .*/   "X  " ,  90 , 'T' },
  {/*.  26     .*/   "0  " ,   1 , 'T' },
  {/*.  27     .*/   "1  " ,   4 , 'T' },
  {/*.  28     .*/   "2  " ,   9 , 'T' },
  {/*.  29     .*/   "3  " ,  12 , 'T' },
  {/*.  30     .*/   "4  " ,  15 , 'T' },
  {/*.  31     .*/   "5  " ,  18 , 'T' },
  {/*.  32     .*/   "6  " ,  21 , 'T' },
  {/*.  33     .*/   "7  " ,  24 , 'T' },
  {/*.  34     .*/   "8  " ,  27 , 'T' },
  {/*.  35     .*/   "9  " ,  30 , 'T' },
  {/*.  36     .*/   "+  " , 107 , 'T' },
  {/*.  37     .*/   "-  " , 110 , 'T' },
  {/*.  38     .*/   ":  " ,   0 , 'T' },
  {/*.  39     .*/   "I  " ,   0 , 'T' },
  {/*.  40     .*/   "R  " ,   0 , 'T' },
  {/*.  41     .*/   "N  " ,   0 , 'T' },
  {/*.  42     .*/   "O  " ,   0 , 'T' },
  {/*.  43     .*/   "T  " ,   0 , 'T' },
  {/*.  44     .*/   "S  " ,   0 , 'T' },
  {/*.  45     .*/   "(  " ,   0 , 'T' },
  {/*.  46     .*/   ")  " ,   0 , 'T' },
  {/*.  47     .*/   "   " ,   0 , 'T' },
  {/*.  48     .*/   ";  " ,   0 , 'T' },
  {/*.  49     .*/   "L  " ,   0 , 'T' },
  {/*.  50     .*/   "F  " ,   0 , 'T' },
  {/*.  51     .*/   "=  " ,   0 , 'T' },
  {/*.  52     .*/   "H  " ,   0 , 'T' },
  {/*.  53     .*/   "*  " , 198 , 'T' }
};

/*
***** Т а б л и ц а  матрицы смежности - основа построения матрицы
***** преемников
*/

char TPR [ NVXOD ] [ NNETRM ] =
 {
/*
   __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
  |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK:CMP|
  |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
  {/*AVI*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*BUK*/ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*CIF*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0  },
  {/*IDE*/ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*IPE*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1  },
  {/*IPR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0  },
  {/*LIT*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*MAN*/ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*ODC*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0  },
  {/*OEN*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*OPA*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*OPR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0  },
  {/*PRO*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*RZR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0  },
  {/*TEL*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0  },
  {/*ZNK*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*CMP*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
/*                                                                          
   __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
  |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNL:CMP|
  |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
  {/*  A*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  B*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  C*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  D*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  E*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  M*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  P*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  X*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  0*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  1*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  2*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  3*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  4*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  5*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0  },
  {/*  6*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0  },
  {/*  7*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
/*                                                                          
   __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
  |       AVI:BUK:CIF:IDE;IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNL:CMP|
  |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
  {/*  8*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  9*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  +*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1  },
  {/*  -*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1  },
  {/*  :*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  I*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  R*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  N*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  O*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  T*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  S*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  (*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  )*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  ;*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*   */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  L*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
/*                                                                          
   __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
  |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN;OPA:OPR:PR0:RZR:TEL:ZNL:ZNK|
  |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
  {/*  F*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  =*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  H*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },
  {/*  **/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1  }
/*|___________________________________________________________________________| */
  };
/*..........................................................................*/

/*
****** Н А Ч А Л О  обработки исходного текста
*/

/* Программа уплотнения исходного текста путем удаления "лишних" пробелов, выполняющая роль примитивного лексического анализатора */
void compress_ISXTXT()
{
    unsigned i = 0;
    unsigned j = 0;
    unsigned out_str_size = 0;
    char last_ch = ' ';
    char curr_ch = ' ';

    for (i = 0; i < NISXTXT; i++)
    {
        for (j = 0; j < 80; j++)
        {
            curr_ch = ISXTXT[i][j];

            if (curr_ch == '\x0')
            {
                break;
            }
            else if (curr_ch == '\n')
            {
                dbg("Skip new line");
            }
            else if ((curr_ch == ' ') && (last_ch == ' ' || last_ch == ';' || last_ch == ')' || last_ch == ':' || last_ch == '('))
            {
                last_ch = curr_ch;
            }
            else if ((curr_ch == '+' || curr_ch == '-' || curr_ch == '=' || curr_ch == '(' || curr_ch == ')' || curr_ch == '*') && (last_ch == ' '))
            {
                out_str_size--;
                last_ch = curr_ch;
                STROKA[out_str_size] = curr_ch;
                out_str_size++;
            }
            else if ((curr_ch == ' ') && (last_ch == '+' || last_ch == '-' || last_ch == '*' || last_ch == '='))
            {
                dbg("skip space");
            }
            else
            {
                last_ch = curr_ch;
                STROKA[out_str_size] = curr_ch;
                out_str_size++;
            }
        }
    }
    STROKA [out_str_size] = '\x0';
}

/* Построение таблицы преемников из матрицы смежности по алгоритму Варшалла */
void build_TPR ()
{
    for ( I1 = 0; I1 < NNETRM; I1++ )
    {
        for ( I2 = 0; I2 < NVXOD; I2++ )
        {
            if ( TPR [ I2 ][ I1 ] & ( I1 != I2 ) )
            {
                for ( I3 = 0; I3 < NNETRM; I3++ )
                {
                    TPR [ I2 ][ I3 ] |= TPR [ I1 ][ I3 ];
                }
            }
        }
    }
}

/* программа заполнения ячейки стека поставленных целей */
void mcel(char* T1, int T2, int T3)
{
    strcpy ( CEL [ K ].CEL1, T1 );
    CEL [ K ].CEL2 = T2;
    CEL [ K ].CEL3 = T3;
    K++;
}

/* программа заполнения ячейки стека достигнутых целей */
void mdst ( char* T1, int T2, int T3, int T4, int T5 )
{
    strcpy ( DST [ L ].DST1, T1 );
    DST [ L ].DST2 = T2;
    DST [ L ].DST3 = T3;
    DST [ L ].DST4 = T4;
    DST [ L ].DST5 = T5;
    L++;
}

/* программа вычисления порядкового номера строки в табл. VXOD, соответствующей строке-параметру функц. */
int numb(char* T1, int T2)
{
    int k;

    for ( I1 = 0; I1 < NVXOD; I1++ )
    {
        for ( k = 0; k < T2; k++ )
        {
            if ( (*(T1+k) != VXOD [ I1 ].SYM [k] ) )
            {
                goto numb1;
            }
        }
        if ( (VXOD [ I1 ].SYM [k] == '\x0') || (VXOD [ I1 ].SYM [k] == ' '  ) )
        {
            return ( I1 );
        }
numb1:
        continue;
    }

    return -1;
}


/* программа построения  дерева синтаксического разбора, выполняющая роль синтаксического анализатора */
int sint_ANAL()
{
    I4 = 0;
    K = 0;
    L = 0;
    I = 0;
    J = 1;
    mcel ( "PRO" , I , 999 );

    if (!TPR [numb ( &STROKA [I], 1 )][numb ( "PRO", 3 )])
    {
        return 1;
    }

L2:

    J = VXOD [ numb ( &STROKA [ I ], 1 ) ].VX ;

L3:

    J = SINT [ J ].POSL;

L31:

    I++;

    if ( I > I4 )
    {
        I4 = I;
    }

    if (VXOD [ numb ( SINT [ J ].DER, 3 ) ].TYP == 'T')
    {
        if ( STROKA [ I ] == SINT [ J ].DER [ 0 ] )
        {
            goto L3;
        }
        else
        {
            goto L8;
        }
    }

    if ( SINT [ SINT [ J ].POSL ].DER [ 0 ] == '*' )
    {
        I--;
        if ( !strcmp (SINT [J].DER, CEL [K-1].CEL1 ) )
        {
            mdst ( CEL[K-1].CEL1,CEL[K-1].CEL2,CEL[K-1].CEL3,I,J );
            if ( !strcmp( CEL[K-1].CEL1 , "PRO" ) )
            {
                return 0;
            }

            if (TPR [numb (CEL[K-1].CEL1, 3)] [numb (CEL[K-1].CEL1, 3)])
            {
                J = VXOD [ numb ( CEL[K-1].CEL1, 3 ) ].VX;
                goto L3;
            }

L6:

            J = CEL[K-1].CEL3;
            K--;
            goto L3;
        }

        if (!TPR [numb (SINT[J].DER, 3)] [numb (CEL[K-1].CEL1, 3)])
        {
            goto L9;
        }

        mdst ( SINT[J].DER, CEL[K-1].CEL2,0,I,J );
        J = VXOD [numb (SINT[J].DER, 3)].VX;
        goto L3;
    }

    if (!TPR [numb (&STROKA [I], 1)] [numb (SINT[J].DER, 3)])
    {
        goto L8;
    }

    mcel ( SINT[J].DER,I,J );
    goto L2;

L8:

    I--;

L9:

    if (SINT[J].ALT != 0)
    {
        J = SINT[J].ALT;
        goto L31;
    }

    J = SINT[J].PRED;

    if (( VXOD [numb (SINT[J].DER, 3)].TYP == 'N' ) && (SINT[J].PRED > 0))
    {
        mcel (DST[L-1].DST1, DST[L-1].DST2, DST[L-1].DST3);

L10:

        J = DST[L-1].DST5;
        L--;
        goto L9;
    }

    if (( VXOD [numb (SINT[J].DER, 3)].TYP == 'N' ) && (SINT[J].PRED == 0))
    {
        if (!strcmp ( CEL[K-1].CEL1, DST[L-1].DST1 ))
        {
            goto L6;
        }
        else
        {
            goto L10;
        }
    }

    if ( SINT[J].PRED > 0 )
    {
        goto L8;
    }

    J = CEL[K-1].CEL3;
    K--;

    if ( J == 999 )
    {
        return 2;
    }
    else
    {
        goto L8;
    }
}

/* таблица имен меток и переменных, заполняемая на первом проходе семантического вычисления и используемая на втором проходе семантического вычисления */
struct
{
    char NAME [8];
    char TYPE;
    char RAZR [5];
    char INIT [50];
}   SYM [ NSYM ];

/* текущий индекс таблицы имен */
unsigned ISYM = 0;

/* хранилище имени транслируемой программы */
static char *file_name = NULL;

static void GenerateNativeCommand(IBM370_ASM_COMMAND command )
{
    memcpy(ASSTXT[ IASSTXT++], command.BUFCARD, 80 );
}

static void SetOperation ( IBM370_ASM_COMMAND *command, const char * operation )
{
    strcpy ( command->_BUFCARD.OPERAC, operation );
    command->_BUFCARD.OPERAC[strlen( command->_BUFCARD.OPERAC ) ] = ' ';
}

static void SetLabel ( IBM370_ASM_COMMAND *command, const char * label )
{
    strcpy ( command->_BUFCARD.METKA, label );
    command->_BUFCARD.METKA[strlen( command->_BUFCARD.METKA ) ] = ' ';
}

static void SetNativeCommandTypeForCmp ( int varIndex, IBM370_ASM_COMMAND *command )
{
    if ( SYM[varIndex].TYPE == IBM370_VAR_TYPE_PACKED_DECIMAL)
    {
        SetOperation (command, IBM370_ASM_CONVERT_PACKED_DECIMAL_TO_BINARY );
    }
    else if ( SYM[varIndex].TYPE == IBM370_VAR_TYPE_BINARY)
    {
        SetOperation (command, IBM370_ASM_LOAD_HALFWORD);
    }
    else
    {
        return;
    }
}

static void SetOperands ( IBM370_ASM_COMMAND *command, const char * operand1, const char * operand2 )
{
    strcpy ( command->_BUFCARD.OPERAND, operand1 );
    strcat ( command->_BUFCARD.OPERAND, ","      );
    strcat ( command->_BUFCARD.OPERAND, operand2 );
    command->_BUFCARD.OPERAND[strlen(command->_BUFCARD.OPERAND)] = ' ';
}

/* программа перевода двоичной константы из ASCIIz-вида во внутреннее представление типа long int */
long int VALUE(char* s )
{
    long int S = 0;
    int i = 0;

    while ( *(s + i) != 'B' )
    {
        S <<= 1;
        if ( *(s + i) == '1' )
        {
            S++;
        }
        i++;
    }
    return (S);
}

/* программа представления фрагмента плотного текста в виде массива 9-ти символьных лексем */
void FORM()
{
    int i,j;

    for ( IFORMT = 0; IFORMT < MAXFORMT; IFORMT++ )
    {
        memcpy ( FORMT [IFORMT], "\x0\x0\x0\x0\x0\x0\x0\x0\x0", 9 );
    }

    IFORMT = 0;
    j = DST [I2].DST2;

FORM1:

    for ( i = j; i <= DST [I2].DST4+1; i++ )
    {
        if (STROKA [i] == ':' || STROKA [i] == ' ' ||
            STROKA [i] == '(' || STROKA [i] == ')' ||
            STROKA [i] == ';' || STROKA [i] == '+' ||
            STROKA [i] == '-' || STROKA [i] == '=' ||
            STROKA [i] == '*')
        {
            FORMT [IFORMT] [i-j] = '\x0';
            IFORMT ++;
            j = i+1;
            goto FORM1;
        }
        else
        {
            FORMT [IFORMT][i-j] = STROKA [i];
        }
    }
    return;
}

/* программа записи очередной сгенерированной записи выходного файла в массив ASSTXT */
void ZKARD()
{
    unsigned i;
    memcpy ( ASSTXT [ IASSTXT++ ], ASS_CARD.BUFCARD, 80 );

    for ( i = 0; i < 79; i++ )
    {
        ASS_CARD.BUFCARD [i] = ' ';
    }
    return;
}

/* программа семантич. вычисления нетерминала AVI на первом проходе. Здесь AVI - "арифм.выраж." */
int AVI1()
{
    return 0;
}

/* программа семантич. вычисления нетерминала BUK на первом проходе. Здесь BUK - "буква" */
int BUK1()
{
    return 0;
}

/* программа семантич. вычисления нетерминала CIF на первом проходе. Здесь CIF - "цифра" */
int CIF1()
{
    return 0;
}

/* программа семантич. вычисления нетерминала IDE на первом проходе. Здесь IDE - "идентификатор" */
int IDE1 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала IPE на первом проходе. Здесь IPE - "имя переменной" */
int IPE1 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала IPR на первом проходе. Здесь IPR - "имя программы" */
int IPR1 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала LIT на первом проходе. Здесь LIT - "литерал" */
int LIT1 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала MAN на первом проходе. Здесь MAN - "мантисса" */
int MAN1 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала ODC на первом проходе. Здесь ODC - "операт.ПЛ1- DCL" */
int ODC1 ()
{
    unsigned i;
    /* форматирование ПЛ1-оператора DCL */
    FORM ();
    for ( i = 0; i < ISYM; i++ )
    {
        /* если фиксируем повтор-повторное объявление второго терма оператора DCL, то завершение программы по ошибке*/
        if (!strcmp ( SYM [i].NAME, FORMT [1] ) && (strlen (SYM [i].NAME) == strlen (FORMT [1])))
        {
            return 6;
        }
    }
    /* при отсутствии повторного объявления идентификатора запоминаем его в табл.SYM */

    strcpy ( SYM [ISYM].NAME, FORMT [1] );

    if (strcmp(FORMT[4], "INIT") == 0)
    {
        /* short declaration */
        strcpy(SYM[ISYM].RAZR, "3"); //default size = 3
    }
    else
    {
        /* long declaration */
        strcpy(SYM[ISYM].RAZR, FORMT[4]);
    }

    /* если идентификатор определен как bin fixed, то устанавливаем тип идентификатора = 'B' и идем на продолжение обработки */
    if ( !strcmp ( FORMT [2], "BIN" ) && !strcmp ( FORMT [3], "FIXED" ) )
    {
        SYM [ISYM].TYPE = 'B';
        goto ODC11;
    }
    /* DCL B DEC FIXED INIT(3) */
    else if (!strcmp(FORMT[2], "DEC") && !strcmp(FORMT[3], "FIXED"))
    {
        dbg("Set name = %s", SYM[ISYM].NAME);
        SYM[ISYM].TYPE = IBM370_VAR_TYPE_PACKED_DECIMAL;
        goto ODC11;
    }
    /* иначе устанавливаем тип идентификатора = 'U' и завершаем программу по ошибке */
    else
    {
        SYM [ISYM].TYPE = 'U';
        return 2;
    }

ODC11:
    /* если идентификатор имеет начальную инициализацию, то запоминаем в табл. SYM это начальное значение */
    if (!strcmp(FORMT[5], "INIT"))
    {
        strcpy (SYM[ISYM++].INIT, FORMT[6]);
    }
    /* short declaration */
    else if (!strcmp(FORMT[4], "INIT"))
    {
        strcpy(SYM[ISYM++].INIT, FORMT[5]);
    }
    /* иначе инициализируем идентификатор нулем */
    else
    {
        if (SYM[ISYM].TYPE == 'B' )
        {
            strcpy(SYM[ISYM++].INIT, "0" );
        }
        else
        {
            // +0
            strcpy(SYM[ISYM++].INIT, "0C" );
        }
    }

    /* успешное завешение программы */
    return 0;
}

/* программа семантич. вычисления нетерминала OEN на первом проходе. Здесь OEN - "операт.ПЛ1-END" */
int OEN1 ()
{
    unsigned i = 0;
    /* форматирование ПЛ1-оператора END */
    FORM ();

    for ( i = 0; i < ISYM; i++ )
    {
        /* если вторй терм оператора END записан в табл SYM и его тип = "P",то: */
        if ( !strcmp ( SYM [i].NAME, FORMT [1] ) && (SYM [i].TYPE == 'P') && strlen (SYM [i].NAME) == strlen ( FORMT [1] ) )
        {
            /* успешное завершение программы */
            return 0;
        }
    }

    /* завершение программы по ошибке */
    return 1;
}

/* программа семантич. вычисления нетерминала OPA на первом проходе. Здесь OPA - "операт.присваивания арифметический */
int OPA1 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала OPR на первом проходе. Здесь OPR - "операт.ПЛ1-PROC" */
int OPR1 ()
{
    /* форматируем оператор ПЛ1 PROC */
    FORM ();

    /* перепишем имя ПЛ1-программы в табл. SYM*/
    strcpy ( SYM [ISYM].NAME, FORMT [0] );

    /* установим тип этого имени = 'P' */
    SYM [ISYM].TYPE = 'P';

    /* установим разрядность равной 0 */
    SYM [ISYM++].RAZR [0] = '\x0';

    /* успешное завершение программы */
    return 0;
}

/* программа семантич. вычисления нетерминала PRO на первом проходе. Здесь PRO - "программа" */
int PRO1 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала RZR на первом проходе. Здесь RZR - "разрядность" */
int RZR1 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала TEL на первом проходе. Здесь TEL - "тело программы" */
int TEL1 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала ZNK на первом проходе. Здесь ZNK - "знак операции" */
int ZNK1 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала AVI на втором проходе. Здесь AVI - "арифм.выраж." */
int AVI2 ()
{
    unsigned i;

    /* форматируем правую часть арифметического ПЛ1-оператора присваивания */
    FORM ();

    /* если правая часть однотермовая, то: */
    if ( IFORMT == 1 )
    {
        /* ищем этот терм в таблице имен */
        for ( i = 0; i < ISYM; i++ )
        {
            /* если находим, то: */
            if ( !strcmp ( SYM [i].NAME, FORMT [0] ) && strlen ( SYM [i].NAME ) == strlen ( FORMT [0] ))
            {
                /* в случае типа=bin fixed */
                if ( SYM [i].TYPE == 'B' )
                {
                    dbg("Rzr = %s", SYM[i].RAZR);
                    /* и разрядности <= 15 */
                    if ( strcmp ( SYM [i].RAZR, "15" ) <= 0 )
                    {
                        /* формируем код ассемблеровской операции LH */
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, "LH", 2 );
                    }
                    else
                    {
                        /* а при разрядности >15 формируем код ассемблеровской операции L */
                        memcpy ( ASS_CARD._BUFCARD.OPERAC,"L", 1 );
                    }

                    /* формируем первый и второй операнды ассемблеровской операции */
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, "RRAB,");
                    strcat ( ASS_CARD._BUFCARD.OPERAND, FORMT [0]);

                    /* вставляем разделитель */
                    ASS_CARD._BUFCARD.OPERAND [ strlen ( ASS_CARD._BUFCARD.OPERAND ) ] = ' ';

                    /* и построчный коментарий */
                    memcpy ( ASS_CARD._BUFCARD.COMM, "Загрузка переменной в регистр", strlen("Загрузка переменной в регистр"));

                    /* запомнить операцию ассемблера и завершить программу */
                    ZKARD ();
                    return 0;
                }
                else
                {
                    /* если тип терма не bin fixed,то выход по ошибке */
                    return 3;
                }
            }
        }

        /* если терм-идентификатор неопределен, то выход по ошибке */
        return 4;
    }
    /* если правая часть арифметического выражения двухтермовая, то: */
    else
    {
        for ( i = 0; i < ISYM; i++ )
        {
            /* если правый терм арифметического выражения определен в табл.SYM,то: */
            if (!strcmp ( SYM [i].NAME, FORMT [IFORMT-1] ) && strlen ( SYM [i].NAME ) == strlen ( FORMT [IFORMT-1] ))
            {
                /* если тип правого операнда bin fixed, то: */
                if ( SYM [i].TYPE == 'B' )
                {
                    /* если знак опер."+",то: */
                    if ( STROKA [ DST [I2].DST4 - strlen( FORMT [IFORMT-1] ) ] == '+' )
                    {
                        /* если разрядность прав. операнда <= 15, то: */
                        if ( strcmp ( SYM [i].RAZR, "15" ) <= 0 )
                        {
                            /* формируем код ассемблеровской операции "AH" */
                            memcpy ( ASS_CARD._BUFCARD.OPERAC, "AH", 2 );
                        }
                        else
                        {
                            /* иначе - "A" */
                            memcpy ( ASS_CARD._BUFCARD.OPERAC, "A", 1 );
                        }
                    }
                    else
                    {
                        /* если же знак операции арифметического выражения "-", то: */
                        if ( STROKA [ DST [I2].DST4 - strlen ( FORMT [IFORMT-1] ) ] == '-' )
                        {
                            /* при разрядности арифметич.выраж.<= 15 */
                            if ( strcmp ( SYM [i].RAZR, "15" ) <= 0 )
                            {
                                /* формируем код ассемблеровской операции "SH" */
                                memcpy( ASS_CARD._BUFCARD.OPERAC, "SH", 2 );
                            }
                            else
                            {
                                /* иначе - "S" */
                                memcpy( ASS_CARD._BUFCARD.OPERAC, "S", 1 );
                            }
                        }
                        else
                        {
                            /* если знак операции не "+" и не "-", то завершение  программы  по ошибке */
                            return 5;
                        }
                    }

                    /* формируем: первый операнд ассемблеровской операции; */
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, "RRAB," );

                    /* - второй операнд ассемблеровской операции; */
                    strcat ( ASS_CARD._BUFCARD.OPERAND, FORMT [IFORMT-1] );

                    /* - разделяющий пробел; */
                    ASS_CARD._BUFCARD.OPERAND [ strlen ( ASS_CARD._BUFCARD.OPERAND )] = ' ';

                    /* - построчный коментарий */
                    memcpy ( ASS_CARD._BUFCARD.COMM, "Формирование промежуточного значения", strlen("Формирование промежуточного значения"));

                    /* запоминание ассемблеровской операции */
                    ZKARD ();

                    /* успешное завершение программы */
                    return 0;
                }
                else
                {
                    /* если тип правого операнда арифметического выражения не bin fixed, то завершение программы по ошибке */
                    return 3;
                }
            }
        }

        /* если правый операнд арифметического выражения не определен в табл. SYM, то завершить программу по ошибке */
        return 4;
    }

}

/* программа семантич. вычисления нетерминала BUK на втором проходе. Здесь BUK - "буква" */
int BUK2 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала CIF на втором проходе. Здесь CIF - "цифра" */
int CIF2 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала IDE на втором проходе. Здесь IDE -   "идентификатор" */
int IDE2 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала IPE на втором проходе. Здесь IPE - "имя переменной" */
int IPE2 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала IPR на втором проходе. Здесь IPR - "имя программы" */
int IPR2 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала LIT на втором проходе. Здесь LIT - "литерал" */
int LIT2 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала MAN на втором проходе. Здесь MAN - "мантисса" */
int MAN2 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала ODC на втором проходе. Здесь ODC - "операт.ПЛ1- DCL" */
int ODC2 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала OEN на втором проходе. Здесь OEN - "операт.ПЛ1-END" */
/* программа формирует эпилог ассемблеровского эквивалента ПЛ1-программы */
int OEN2 ()
{
    char RAB [20];
    unsigned i = 0;

    /* форматируем ПЛ1-опера тор END */
    FORM ();

    /* формируем код безусловного возврата управления в вызывающую программу */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "BCR", 3 );

    /* операнды команды и поле построчного коментария */
    memcpy ( ASS_CARD._BUFCARD.OPERAND,"15,14", 5 );
    memcpy ( ASS_CARD._BUFCARD.COMM, "Выход из программы", strlen("Выход из программы"));

    /* запомнить опреацию Ассемблера */
    ZKARD ();

    /* далее идет блок формирования декларативных псевдоопераций DC для каждого идентификатора, попавшего в табл.SYM */
    for ( i = 0; i < ISYM; i++ )
    {
        if (strcmp(SYM[i].NAME, "TMP") == 0)
        {
            memcpy(ASS_CARD._BUFCARD.OPERAC, "DS", 2);
            memcpy(ASS_CARD._BUFCARD.OPERAND, "0F", 2);

            ZKARD();
        }
        /* если строка табл.SYM содержит идентификатор, т.е.начинается с буквы, то: */
        if ( isalpha ( SYM [i].NAME [0] ) )
        {

            /* если тип оператора bin fixed, то: */
            if ( SYM [i].TYPE == 'B' )
            {
                /* пишем идентификатор в поле метки псевдооперации DC*/
                strcpy ( ASS_CARD._BUFCARD.METKA, SYM [i].NAME );

                /* пишем разделитель полей */
                ASS_CARD._BUFCARD.METKA [ strlen ( ASS_CARD._BUFCARD.METKA ) ] = ' ';

                /* пишем код псевдооперации DC */
                memcpy ( ASS_CARD._BUFCARD.OPERAC, "DC", 2 );

                /* формируем операнды псевдооперации DC */
                if ( strcmp ( SYM [i].RAZR, "15" ) <= 0 )
                {
                    /* для случая полуслова */
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, "H\'");
                }
                else if ( strcmp ( SYM [i].RAZR, "3" ) == 0 )
                {
                    /* для случая полуслова */
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, "H\'");
                }
                else
                {
                    /* для случая слова */
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, "F\'");
                }

                strcat(ASS_CARD._BUFCARD.OPERAND, SYM[i].INIT);
                //strcat(ASS_CARD._BUFCARD.OPERAND, gcvt(VALUE(SYM[i].INIT), 10, &RAB[0]));

                /* замыкающий апостроф */
                ASS_CARD._BUFCARD.OPERAND [ strlen( ASS_CARD._BUFCARD.OPERAND ) ] = '\'';

                /* поле построчного коментария */
                memcpy ( ASS_CARD._BUFCARD.COMM, "Определение переменной", strlen("Определение переменной"));

                /* запомнить операцию Ассемблера */
                ZKARD ();
            }
            else if ( SYM [i].TYPE == IBM370_VAR_TYPE_PACKED_DECIMAL )
            {
                /* пишем идентификатор в поле метки псевдооперации DC */
                strcpy (  ASS_CARD._BUFCARD.METKA, SYM [i].NAME );
                /* пишем разделитель полей*/
                ASS_CARD._BUFCARD.METKA [ strlen( ASS_CARD._BUFCARD.METKA ) ] = ' ';

                /* пишем код псевдооперации DC */
                memcpy ( ASS_CARD._BUFCARD.OPERAC, "DC", 2 );

                strcpy( ASS_CARD._BUFCARD.OPERAND,"P");

                dbg("razr = %s", SYM [i].RAZR);
                /* формируем операнды псевдооперации DC */
                if ( strcmp ( SYM [i].RAZR, "8" ) == 0 )
                {
                    /* для случая полуслова */
                    strcat(ASS_CARD._BUFCARD.OPERAND, "L8");
                }
                else if ( strcmp ( SYM [i].RAZR, "3" ) == 0 )
                {
                    /* для случая полуслова */
                    strcat(ASS_CARD._BUFCARD.OPERAND, "L3");
                }
                else
                {
                    /* для случая слова */
                    strcat(ASS_CARD._BUFCARD.OPERAND, "L3");
                }

                strcat(ASS_CARD._BUFCARD.OPERAND, "\'");
                strcat ( ASS_CARD._BUFCARD.OPERAND, SYM[i].INIT );

                /* замыкающий апостроф    */
                ASS_CARD._BUFCARD.OPERAND [ strlen( ASS_CARD._BUFCARD.OPERAND ) ] = '\'';

                /* поле построчного коментария  */
                memcpy ( ASS_CARD._BUFCARD.COMM, "Определение переменной", strlen("Определение переменной") );

                /* запомнить операцию Ассемблера */
                ZKARD ();
            }
        }
    }

    /* далее идет блок декларативных ассемблеровских EQU-операторов, определяющих базовый и рабочий регистры общего назначения */

    /* формирование EQU-псевдооперации определения номера базового регистра общего назначения*/
    memcpy ( ASS_CARD._BUFCARD.METKA, "RBASE", 5 );
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU", 3 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "15", 2 );

    /* запоминание ее */
    ZKARD ();

    /* формирование EQU-псевдооперации определения номера базового регистра общего назначения*/
    memcpy ( ASS_CARD._BUFCARD.METKA, "RRAB", 4 );
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU", 3 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "5", 1 );

    /* запоминание ее */
    ZKARD ();

    /* Регистр для промежуточных результатов */
    memcpy ( ASS_CARD._BUFCARD.METKA, "RTMP", 4 );
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU",3 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "6", 1 );

    /* запоминание ее */
    ZKARD ();

    /* формирование кода ассемблеровской псевдооперации END, */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "END", 3 );

    i = 0;

    /* ее операнда */
    while ( FORMT [1][i] != '\x0' )
    {
        ASS_CARD._BUFCARD.OPERAND [i] = FORMT [1][i];
        i++;
    }

    /* построчного коментария */
    memcpy ( ASS_CARD._BUFCARD.COMM, "Конец программы", strlen("Конец программы"));

    /* запоминание псевдооперации */
    ZKARD ();

    /* завершение программы */
    return 0;
}

/* программа семантич. вычисления нетерминала OPA на втором проходе. Здесь OPA - "операт.присваивания арифметический */
int OPA2()
{
    unsigned i;

    /*форматируем ПЛ1-оператор присваивания арифметич. */
    FORM ();

    for ( i = 0; i < ISYM; i++ )
    {
        /* если идентификатор правой части оператора определен ранее через оператор DCL, то:*/
        if ( !strcmp ( SYM [i].NAME, FORMT [0] ) && strlen ( SYM [i].NAME ) == strlen ( FORMT [0] ))
        {
            /* если этот идентификатор имеет тип bin fixed,то: */
            if ( SYM [i].TYPE == 'B' )
            {
                /* если bin fixed (15),то: */
                if ( strcmp ( SYM [i].RAZR, "15" ) <= 0 )
                {
                    /* сформировать команду записи полуслова */
                    memcpy ( ASS_CARD._BUFCARD.OPERAC,"STH", 3 );
                }
                else if ( strcmp ( SYM [i].RAZR, "3" ) == 0 )
                {
                    memcpy ( ASS_CARD._BUFCARD.OPERAC, "STH", 2 );
                }
                /* иначе: команду записи слова */
                else
                {
                    memcpy ( ASS_CARD._BUFCARD.OPERAC, "ST", 2 );
                }

                dbg("tmp_metka = %p", tmp_metka);
                if (tmp_metka != NULL)
                {
                    dbg("tmp_metka = %s", tmp_metka);
                    strcpy(ASS_CARD._BUFCARD.METKA, tmp_metka);
                    ASS_CARD._BUFCARD.METKA[strlen(ASS_CARD._BUFCARD.METKA)] = ' ';
                }

                /* доформировать операнды */
                strcpy ( ASS_CARD._BUFCARD.OPERAND, "RRAB," );

                /* команды */
                strcat ( ASS_CARD._BUFCARD.OPERAND, FORMT [0]) ;

                ASS_CARD._BUFCARD.OPERAND [ strlen( ASS_CARD._BUFCARD.OPERAND ) ] = ' ';

                /* построчный коментарий */
                memcpy ( ASS_CARD._BUFCARD.COMM, "Форм. значения арифм.выр.", strlen("Форм. значения арифм.выр."));

                /* запомнить операцию Ассемблера */
                ZKARD ();

                /* завершить программу */
                return 0;
            }
            /* если этот идентификатор имеет тип DEC fixed,то: */
            else if ( SYM [i].TYPE == IBM370_VAR_TYPE_PACKED_DECIMAL )
            {
                IBM370_ASM_COMMAND ST_RRAB_ZZ4;
                memset ( &ST_RRAB_ZZ4, 32, 80 );
                SetOperation (&ST_RRAB_ZZ4, IBM370_ASM_STORE );
                SetOperands( &ST_RRAB_ZZ4, "RRAB", "ZZ4" );

                IBM370_ASM_COMMAND MVC_GSG_ZZ4;
                memset ( &MVC_GSG_ZZ4, 32, 80 );
                SetOperation (&MVC_GSG_ZZ4, IBM370_ASM_MOVE_CHARACTERS );
                SetOperands ( &MVC_GSG_ZZ4, "GSG+12(4)", "ZZ4" );

                IBM370_ASM_COMMAND CVD_RRAB_GSG;
                memset (&CVD_RRAB_GSG , 32, 80 );
                SetOperation ( &CVD_RRAB_GSG, IBM370_ASM_CONVERT_BINARY_TO_PACKED_DECIMAL );
                SetOperands ( &CVD_RRAB_GSG, "RRAB", "GSG" );


                IBM370_ASM_COMMAND ST_RRAB_M4;
                memset (&ST_RRAB_M4 , 32, 80 );
                SetOperation (&ST_RRAB_M4, IBM370_ASM_STORE );
                SetOperands( &ST_RRAB_M4, "RRAB", "ZZ4" );

                IBM370_ASM_COMMAND MVC_C_ZZZ4;
                memset (&MVC_C_ZZZ4, 32, 80 );
                SetOperation (&MVC_C_ZZZ4, IBM370_ASM_MOVE_CHARACTERS );
                SetOperands ( &MVC_C_ZZZ4, FORMT[0], "ZZ4" );

                IBM370_ASM_COMMAND MVC_GSG_ZZZ;
                memset (&MVC_GSG_ZZZ , 32, 80 );
                SetOperation (&MVC_GSG_ZZZ, IBM370_ASM_MOVE_CHARACTERS );
                SetOperands ( &MVC_GSG_ZZZ, "GSG", "ZZZ" );
                IBM370_ASM_COMMAND MVC_ZZ4_ZZZ;
                memset (&MVC_ZZ4_ZZZ , 32, 80 );
                SetOperation (&MVC_ZZ4_ZZZ, IBM370_ASM_MOVE_CHARACTERS );
                SetOperands ( &MVC_ZZ4_ZZZ, "ZZ4", "ZZZ" );

                GenerateNativeCommand(ST_RRAB_ZZ4);
                GenerateNativeCommand(MVC_GSG_ZZ4);
                GenerateNativeCommand(CVD_RRAB_GSG);
                GenerateNativeCommand(ST_RRAB_M4);
                GenerateNativeCommand(MVC_C_ZZZ4);
                GenerateNativeCommand(MVC_GSG_ZZZ);
                GenerateNativeCommand(MVC_ZZ4_ZZZ);
                return 0;
            }
            /* если идентификатор неимеет тип bin fixed,то: */
            else
            {
                /* завершение с диагностикой ошибки */
                return 3;
            }
       }
    }

    /* если идентификатор ранее не определен через ПЛ1-оператор DCL,то завершение с диагностикой ошибки */
    return 4;
}

/* программа семантич. вычисления нетерминала OPR на втором проходе. Здесь OPR - "операт.ПЛ1-PROC" */
/* программа формирует пролог ассемблеровского эквивалента исходной ПЛ1-программы */
int OPR2()
{
    unsigned i = 0;
    /* форматируем оператор ПЛ1 - "начало процедурного блока" */
    FORM ();

    while ( FORMT [0][i] != '\x0' )
    {
        /* нулевой терм используем как метку в START-псевдооперации Ассемблера*/
        ASS_CARD._BUFCARD.METKA [i] = FORMT [0][i];
        i++;
    }

    /* достраиваем код и операнды  в START-псевдооперации Ассемблера */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "START", 5 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "0", 1 );
    memcpy ( ASS_CARD._BUFCARD.COMM, "Начало программы", strlen("Начало программы"));

    /* запоминаем карту Ассемблера */
    ZKARD ();

    /* формируем BALR-операцию Ассемблера */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "BALR", 4 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "RBASE,0", 7 );
    memcpy ( ASS_CARD._BUFCARD.COMM, "Загрузить регистр базы", strlen("Загрузить регистр базы") );

    /* и запоминаем ее */
    ZKARD ();

    /* формируем USING-псевдооперацию Ассемблера */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "USING", 5 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "*,RBASE", 7 );
    memcpy ( ASS_CARD._BUFCARD.COMM, "Назначить регистр базой", strlen("Назначить регистр базой") );

    /* и запоминаем ее */
    ZKARD ();

    /* завершить подпрограмму */
    return 0;
}

/* программа семантич. вычисления нетерминала PRO на втором проходе. Здесь PRO - "программа" */
/* прогр.формирует выходной файл */
int PRO2()
{
    if (file_name == NULL)
    {
        err("file_name is NULL");
        return 7;
    }

    unsigned length = strlen(file_name);
    char out_name[length];
    memset(out_name, 0, length);
    strncpy(out_name, file_name, length - 3);
    /* сформировать имя выходного файла */
    strcat(out_name, "ass");

    FILE *fp = fopen ( out_name , "wb" );
    if (fp == NULL)
    {
        err("Cannot open out file");
        return 7;
    }

    unsigned i = 0;
    for (i = 0; i < IASSTXT; i++)
    {
        fwrite(ASSTXT[i], 80, 1, fp);
        if (READABLE)
        {
            fprintf( fp, "\n" );
        }
    }
    //fwrite(ASSTXT, 80 , IASSTXT , fp);
    fclose(fp);
    return 0;
}

/* программа семантич. вычисления нетерминала RZR на втором проходе. Здесь RZR - "разрядность" */
int RZR2 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала TEL на втором проходе. Здесь TEL - "тело программы" */
int TEL2 ()
{
    return 0;
}

/* программа семантич. вычисления нетерминала ZNK на втором проходе. Здесь ZNK - "знак операции" */
int ZNK2 ()
{
    return 0;
}

int CMP1 ()
{
    return 0;
}

int CMP2 ()
{
    char nextLabel[8];
    char onEqualLabel[8];

    memset ( nextLabel, 0, 8 );

    memset ( onEqualLabel, 0, 8 );

    strncpy( nextLabel, NextLabel, 1 );
    strncpy( onEqualLabel, OnEqualLabel, 1);
    snprintf((nextLabel + 1), 10, "%d", NextLabelIndex);
    snprintf((onEqualLabel + 1), 10, "%d", OnEqualLabelIndex);
//    itoa( NextLabelIndex, (nextLabel + 1), 10);
//    itoa( OnEqualLabelIndex, (onEqualLabel + 1), 10);

    dbg( ">>>CMP2\n" );

    unsigned result = ERROR_SUCCESS;

    FORM();

    int var1Index = IndexNotFound();
    int var2Index = IndexNotFound();

    unsigned i = 0;

    for (i = 0; i < ISYM; i++ )
    {
        // нашли первую переменную?
        if (( 0 == strcmp ( SYM [i].NAME, FORMT [0] ) ) && ( strlen ( SYM [i].NAME ) == strlen ( FORMT [0] ) ))
        {
            var1Index = i;
        }
        // нашли вторую переменную?
        else if (( 0 == strcmp ( SYM [i].NAME, FORMT [1] ) ) && ( strlen ( SYM [i].NAME ) == strlen ( FORMT [1] ) ))
        {
            var2Index = i;
        }
    }

    dbg("index1 = %d, index2 = %d", var1Index, var2Index);
    // нашлись обе переменные?
    if ((var1Index != IndexNotFound()) && (var2Index != IndexNotFound()))
    {
        IBM370_ASM_COMMAND loadVar1;
        IBM370_ASM_COMMAND loadVar2;

        memset(loadVar1.BUFCARD, 32, 80);
        memset(loadVar2.BUFCARD, 32, 80);

        if ( SYM[var1Index].TYPE == 'B' )
        {
            SetOperation(&loadVar1, IBM370_ASM_LOAD_HALFWORD);
            SetOperands(&loadVar1, "RRAB", SYM[var1Index].NAME);
            GenerateNativeCommand(loadVar1);
        }
        else if ( SYM[var1Index].TYPE == IBM370_VAR_TYPE_PACKED_DECIMAL)
        {
            FORM();
            strcpy(SYM[ISYM].NAME, "TMP");
            SYM[ISYM].TYPE = IBM370_VAR_TYPE_PACKED_DECIMAL;
            strcpy(SYM[ISYM].RAZR, "8");
            strcpy(SYM[ISYM].INIT, "0");
            ISYM++;

            IBM370_ASM_COMMAND convertDecToBin;
            memset(convertDecToBin.BUFCARD, 32, 80);

            if ( strcmp(SYM[var1Index].RAZR, "24" ) == 0 )
            {
                SetOperands(&loadVar1, "TMP+13(3)", SYM[var1Index].NAME);
            }
            else
            {
                SetOperands(&loadVar1, "TMP+5(3)", SYM[var1Index].NAME);
            }
            SetOperation(&loadVar1, IBM370_ASM_MOVE_CHARACTERS);
            GenerateNativeCommand(loadVar1);


            SetOperation(&convertDecToBin, IBM370_ASM_CONVERT_PACKED_DECIMAL_TO_BINARY);
            SetOperands(&convertDecToBin, "RTMP", "TMP");
            GenerateNativeCommand(convertDecToBin);
        }


        if ( SYM[var2Index].TYPE == 'B' )
        {
            SetOperation(&loadVar2, IBM370_ASM_LOAD_HALFWORD);
            SetOperands(&loadVar2, "RRAB", SYM[var1Index].NAME );
            GenerateNativeCommand(loadVar2);
        }
        else if ( SYM[var2Index].TYPE == IBM370_VAR_TYPE_PACKED_DECIMAL )
        {
            FORM();
            strcpy(SYM[ISYM].NAME, "TMP");
            SYM[ISYM].TYPE = IBM370_VAR_TYPE_PACKED_DECIMAL;
            strcpy(SYM[ISYM].RAZR, "8");
            strcpy(SYM[ISYM].INIT, "0");
            ISYM++;

            IBM370_ASM_COMMAND convertDecToBin;
            memset(convertDecToBin.BUFCARD, 32, 80);

            if ( strcmp(SYM[var2Index].RAZR, "24" ) == 0 )
            {
                SetOperands(&loadVar2, "TMP+13(3)", SYM[var2Index].NAME );
            }
            else
            {
                SetOperands(&loadVar2, "TMP+5(3)", SYM[var2Index].NAME );
            }
            SetOperation(&loadVar2, IBM370_ASM_MOVE_CHARACTERS);
            GenerateNativeCommand(loadVar2);

            SetOperation(&convertDecToBin, IBM370_ASM_CONVERT_PACKED_DECIMAL_TO_BINARY);
            SetOperands(&convertDecToBin, "RTMP", "TMP");
            GenerateNativeCommand(convertDecToBin);
        }

        IBM370_ASM_COMMAND compare_algebraic;
        memset(compare_algebraic.BUFCARD, 32, 80);
        SetOperation(&compare_algebraic, IBM370_ASM_COMPARE_ALGEBROIC);
        SetOperands(&compare_algebraic, "RRAB", "RTMP");
        GenerateNativeCommand(compare_algebraic);

        IBM370_ASM_COMMAND branch_on_true;
        memset(branch_on_true.BUFCARD, 32, 80);
        SetOperation(&branch_on_true, IBM370_ASM_CONDITIONAL_BRANCH);
        SetOperands(&branch_on_true, "8", "ON_T");
        GenerateNativeCommand(branch_on_true);

        FORM();
        strcpy(SYM[ISYM].NAME, "FALSE");
        SYM[ISYM].TYPE = IBM370_VAR_TYPE_BINARY;
        strcpy(SYM[ISYM].RAZR, "3");
        strcpy(SYM[ISYM].INIT, "0");
        ISYM++;

        IBM370_ASM_COMMAND load_false;
        memset(load_false.BUFCARD, 32, 80);
        SetOperation(&load_false, IBM370_ASM_LOAD_HALFWORD);
        SetOperands(&load_false, "RRAB", "FALSE");
        GenerateNativeCommand(load_false);

        IBM370_ASM_COMMAND branch_on_false;
        memset(branch_on_false.BUFCARD, 32, 80);
        SetOperation(&branch_on_false, IBM370_ASM_CONDITIONAL_BRANCH);
        SetOperands(&branch_on_false, "15", "ON_F");
        GenerateNativeCommand(branch_on_false);

        FORM();
        strcpy(SYM[ISYM].NAME, "TRUE");
        SYM[ISYM].TYPE = IBM370_VAR_TYPE_BINARY;
        strcpy(SYM[ISYM].RAZR, "3");
        strcpy(SYM[ISYM].INIT, "1");
        ISYM++;

        IBM370_ASM_COMMAND on_true;
        memset(on_true.BUFCARD, 32, 80);
        SetLabel(&on_true, "ON_T");
        SetOperation(&on_true, IBM370_ASM_LOAD_HALFWORD);
        SetOperands(&on_true, "RRAB", "TRUE");
        GenerateNativeCommand(on_true);

        tmp_metka = "ON_F";
        dbg("tmp_metka = %p", tmp_metka);
    }
    else
    {
        result = ERROR_VAR_NOT_DEFINED;
    }

    NextLabelIndex++;
    OnEqualLabelIndex++;
    return result;
}

/* Программа управления абстрактной ЭВМ - семантического вычислителя, интерпретирующего абстрактную программу, сформированную синтаксическим анализатором в стеке достигнутых целей. */
/* Суть алгоритма управления  в  последовательной интерпретации строк стека достижений  в направлении от дна к вершине. */
/* При этом каждая строка воспринимается как команда абстрактной ЭВМ со следующими полями: */
/* - DST.DST1 - код операции; */
/* - DST.DST2 - левая граница интерпретируемого фрагмента исх.текста; */
/* - DST.DST4 - правая граница интерпретируемого фрагмента исх.текста. */
int gen_COD ()
{
    int NOSH;

    int (* FUN [NNETRM][2]) () =
    {
        {/*    1  */    AVI1, AVI2 },
        {/*    2  */    BUK1, BUK2 },
        {/*    3  */    CIF1, CIF2 },
        {/*    4  */    IDE1, IDE2 },
        {/*    5  */    IPE1, IPE2 },
        {/*    6  */    IPR1, IPR2 },
        {/*    7  */    LIT1, LIT2 },
        {/*    8  */    MAN1, MAN2 },
        {/*    9  */    ODC1, ODC2 },
        {/*   10  */    OEN1, OEN2 },
        {/*   11  */    OPA1, OPA2 },
        {/*   12  */    OPR1, OPR2 },
        {/*   13  */    PRO1, PRO2 },
        {/*   14  */    RZR1, RZR2 },
        {/*   15  */    TEL1, TEL2 },
        {/*   16  */    ZNK1, ZNK2 },
        {/*   17  */    CMP1, CMP2 }
    };

    /* организация первого прохода семантического вычисления */
    for ( I2 = 0; I2 < L; I2++ )
    {
        NOSH = FUN [numb ( DST [I2].DST1, 3 )][0] ();
        if ( NOSH != 0)
        {
            /* выход из программы по ошибке */
            return (NOSH);
        }
    }

    /* организация второго прохода семантического вычисления */
    for ( I2 = 0; I2 < L; I2++ )
    {
        NOSH = FUN [numb ( DST [I2].DST1, 3 )][1] ();
        if ( NOSH != 0)
        {
            /* выход из программы по ошибке */
            return (NOSH);
        }
    }

    /* успешное завершение программы */
    return 0;
}

/* программа, организующая последовательную обработку исходного текста: лексич.анализатором, синтаксич.анализат., семантич.вычислителем */
int main (int argc, char **argv )
{
    /* проверяем корректность командной строки */
    if (argc != 2)
    {
        err("Ошибка в командной строке");
        return -1;
    }

    /* указатель на первый параметр командной стр. */
    file_name = argv[1];

    /* проверка типа исх.файла*/
    if (strncmp( file_name + strlen(file_name) - 3, "pli", 3))
    {
        err("Неверный тип файла с исходным текстом" );
        return -1;
    }

    FILE *fp = fopen ( file_name , "rb" );

    if (NULL == fp )
    {
        err("Не найден файл с исходным текстом");
        return -1;
    }


    /* пишем файл в массив ISXTXT */
    for ( NISXTXT = 0; NISXTXT <= MAXNISXTXT; NISXTXT++ )
    {
        if ( !fgets ( ISXTXT [NISXTXT], 80, fp ) )
        //if ( !fread ( ISXTXT [NISXTXT], 80, 1, fp ) )
        {
            /* в конце файла идем на метку  main1 */
            if ( feof ( fp ) )
            {
                goto main1;
            }
            else
            {
                err("Ошибка при чтении фыйла с исх.текстом");
                return -1;
            }
        }
    }

    err("Переполнение буфера чтения исх.текста" );
    return -1;

main1:
    fclose(fp);

    /* чистка буфера строки выходного ассемблеровского файла */
    memset (ASS_CARD.BUFCARD, ' ', 80);

    /* лексический анализ исходного текста */
    compress_ISXTXT ();


build_TPR ();                                   /* построение матрицы     */
/* преемников             */

if ( (sint_ANAL ()) )                           /* синтаксический анализ  */
{                                              /* исходного текста       */
STROKA [I4 +20] = '\x0';
printf                                       /* если найдены ошибки    */
(                                           /* синтаксиса, то :       */
"%s%s%s%s\n",
"ошибка синтаксиса в исх.тексте -> ",      /* выдаем диагностику и   */
"\"...",&STROKA [I4], "...\""
);
printf
(
"%s\n", "трансляция прервана"
);
return;                                      /* завершаем трансляцию   */
}
else                                            /* иначе делаем           */
{
switch ( gen_COD () )                         /* семантическое вычислен.*/
{
case  0:                                    /*если код завершения = 0,*/
/* то:                    */

printf ( "%s\n",                           /* - диагностич.сообщение;*/
"трансляция завершена успешно" );
return;                                    /* - завершить трансляцию */


case  1:                                    /*если код завершения = 1,*/
/* то:                    */
printf ( "%s\n",                           /* - диагностич.сообщение;*/
"несовпадение имени процедуры в прологе-эпилоге" );
break;                                     /* - выйти на обобщающую  *//* - диагностич.сообщение;*/
/*диагностику             */

case  2:                                    /*если код завершения = 2,*/
/* то:                    */
STROKA [ DST [I2].DST2 +20 ] = '\x0';      /* - диагностич.сообщение;*/
printf ( "%s%s\n%s%s%s\n",
"недопустимый тип идентификатора: ",
&FORMT [1], " в исх.тексте -> \"...",
&STROKA [ DST [I2].DST2 ], "...\"" );
break;                                     /* - выйти на обобщающую  */
/*диагностику             */

case  3:                                    /*если код завершения = 3,*/
/* то:                    */
STROKA [ DST [I2].DST2 + 20 ] = '\x0';     /* - диагностич.сообщение;*/
printf ( "%s%s\n%s%s%s\n",
"недопустимый тип идентификатора: ",
&FORMT [IFORMT-1], " в исх.тексте -> \"...",
&STROKA [ DST [I2].DST2 ], "...\"" );
break;                                     /* -выйти на обобщающую   */
/*диагностику             */

case  4:                                    /*если код завершения = 4,*/
/* то:                    */
STROKA [ DST [I2].DST2 + 20 ] = '\x0';     /* - диагностич.сообщение;*/
printf ( "%s%s\n%s%s%s\n",
"неопределенный идентификатор: ",
&FORMT [IFORMT-1], " в исх.тексте -> \"...",
&STROKA [ DST [I2].DST2 ], "...\"" );
break;                                     /* - выйти на обобщающую  */
/*диагностику             */

case  5:                                    /*если код завершения = 5,*/
/* то:                    */
STROKA [ DST [I2].DST2 + 20 ] = '\x0';     /* - диагностич.сообщение;*/
printf ( "%s%c\n%s%s%s\n",
"недопустимая операция: ",
STROKA [ DST [I2].DST4 - strlen ( FORMT [IFORMT-1] ) ],
" в исх.тексте -> \"...", &STROKA [ DST [I2].DST2 ], "...\"");
break;                                     /* - выйти на обобщающую  */
/*диагностику             */

case  6:                                    /*если код завершения = 6 */
/* то:                    */
STROKA [ DST [I2].DST2 + 20 ] = '\x0';     /* - диагностич.сообщение;*/
printf ( "%s%s\n%s%s%s\n",
"повторное объявление идентификатора: ",
&FORMT [1], " в исх.тексте -> \"...",
&STROKA [ DST [I2].DST2 ], "...\"" );
break;                                     /* - выйти на обобщающую  */
/*диагностику             */

}

}

printf ( "%s\n", "трансляция прервана" );       /* обобщающая диагностика */

return 0;
}
/*..........................................................................*/
